/*
Slurm REST API

API to access and control Slurm

API version: Slurm-24.05.2&openapi/dbv0.0.39&openapi/v0.0.39&openapi/slurmdbd&openapi/slurmctld
Contact: sales@schedmd.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slurmrest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SlurmdbAPIService SlurmdbAPI service
type SlurmdbAPIService service

type ApiSlurmdbV0040DeleteAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
}

func (r ApiSlurmdbV0040DeleteAccountRequest) Execute() (*V0040OpenapiAccountsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAccountExecute(r)
}

/*
SlurmdbV0040DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0040DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAccount(ctx context.Context, accountName string) ApiSlurmdbV0040DeleteAccountRequest {
	return ApiSlurmdbV0040DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAccountExecute(r ApiSlurmdbV0040DeleteAccountRequest) (*V0040OpenapiAccountsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Account(account string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Cluster(cluster string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Format(format string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Id(id string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040DeleteAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040DeleteAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Partition(partition string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Qos(qos string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040DeleteAssociationRequest) User(user string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040DeleteAssociationRequest) Execute() (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAssociationExecute(r)
}

/*
SlurmdbV0040DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociation(ctx context.Context) ApiSlurmdbV0040DeleteAssociationRequest {
	return ApiSlurmdbV0040DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociationExecute(r ApiSlurmdbV0040DeleteAssociationRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Account(account string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Format(format string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Id(id string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040DeleteAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040DeleteAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Partition(partition string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Qos(qos string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) User(user string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040DeleteAssociationsRequest) Execute() (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAssociationsExecute(r)
}

/*
SlurmdbV0040DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociations(ctx context.Context) ApiSlurmdbV0040DeleteAssociationsRequest {
	return ApiSlurmdbV0040DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociationsExecute(r ApiSlurmdbV0040DeleteAssociationsRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0040DeleteClusterRequest) Classification(classification string) ApiSlurmdbV0040DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040DeleteClusterRequest) Cluster(cluster string) ApiSlurmdbV0040DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0040DeleteClusterRequest) Federation(federation string) ApiSlurmdbV0040DeleteClusterRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0040DeleteClusterRequest) Flags(flags string) ApiSlurmdbV0040DeleteClusterRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0040DeleteClusterRequest) Format(format string) ApiSlurmdbV0040DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0040DeleteClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0040DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040DeleteClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040DeleteClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0040DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0040DeleteClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0040DeleteClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0040DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0040DeleteClusterRequest) Execute() (*V0040OpenapiClustersRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteClusterExecute(r)
}

/*
SlurmdbV0040DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0040DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteCluster(ctx context.Context, clusterName string) ApiSlurmdbV0040DeleteClusterRequest {
	return ApiSlurmdbV0040DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteClusterExecute(r ApiSlurmdbV0040DeleteClusterRequest) (*V0040OpenapiClustersRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiClustersRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
}

func (r ApiSlurmdbV0040DeleteSingleQosRequest) Execute() (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteSingleQosExecute(r)
}

/*
SlurmdbV0040DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0040DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteSingleQos(ctx context.Context, qos string) ApiSlurmdbV0040DeleteSingleQosRequest {
	return ApiSlurmdbV0040DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteSingleQosExecute(r ApiSlurmdbV0040DeleteSingleQosRequest) (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
}

func (r ApiSlurmdbV0040DeleteUserRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteUserExecute(r)
}

/*
SlurmdbV0040DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0040DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteUser(ctx context.Context, name string) ApiSlurmdbV0040DeleteUserRequest {
	return ApiSlurmdbV0040DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteUserExecute(r ApiSlurmdbV0040DeleteUserRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0040DeleteWckeyRequest) Execute() (*V0040OpenapiWckeyRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteWckeyExecute(r)
}

/*
SlurmdbV0040DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0040DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteWckey(ctx context.Context, id string) ApiSlurmdbV0040DeleteWckeyRequest {
	return ApiSlurmdbV0040DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteWckeyExecute(r ApiSlurmdbV0040DeleteWckeyRequest) (*V0040OpenapiWckeyRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiWckeyRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// include associations
func (r ApiSlurmdbV0040GetAccountRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// include coordinators
func (r ApiSlurmdbV0040GetAccountRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// include deleted
func (r ApiSlurmdbV0040GetAccountRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetAccountRequest) Execute() (*V0040OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAccountExecute(r)
}

/*
SlurmdbV0040GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0040GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAccount(ctx context.Context, accountName string) ApiSlurmdbV0040GetAccountRequest {
	return ApiSlurmdbV0040GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAccountExecute(r ApiSlurmdbV0040GetAccountRequest) (*V0040OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// CSV description list
func (r ApiSlurmdbV0040GetAccountsRequest) Description(description string) ApiSlurmdbV0040GetAccountsRequest {
	r.description = &description
	return r
}

// include associations
func (r ApiSlurmdbV0040GetAccountsRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetAccountsRequest {
	r.withAssocs = &withAssocs
	return r
}

// include coordinators
func (r ApiSlurmdbV0040GetAccountsRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetAccountsRequest {
	r.withCoords = &withCoords
	return r
}

// include deleted accounts
func (r ApiSlurmdbV0040GetAccountsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAccountsRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetAccountsRequest) Execute() (*V0040OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAccountsExecute(r)
}

/*
SlurmdbV0040GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAccounts(ctx context.Context) ApiSlurmdbV0040GetAccountsRequest {
	return ApiSlurmdbV0040GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAccountsExecute(r ApiSlurmdbV0040GetAccountsRequest) (*V0040OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040GetAssociationRequest) Account(account string) ApiSlurmdbV0040GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040GetAssociationRequest) Cluster(cluster string) ApiSlurmdbV0040GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetAssociationRequest) Format(format string) ApiSlurmdbV0040GetAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040GetAssociationRequest) Id(id string) ApiSlurmdbV0040GetAssociationRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040GetAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040GetAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040GetAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040GetAssociationRequest) Partition(partition string) ApiSlurmdbV0040GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationRequest) Qos(qos string) ApiSlurmdbV0040GetAssociationRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040GetAssociationRequest) User(user string) ApiSlurmdbV0040GetAssociationRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040GetAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040GetAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040GetAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040GetAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040GetAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040GetAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040GetAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040GetAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040GetAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040GetAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040GetAssociationRequest) Execute() (*V0040OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAssociationExecute(r)
}

/*
SlurmdbV0040GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociation(ctx context.Context) ApiSlurmdbV0040GetAssociationRequest {
	return ApiSlurmdbV0040GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociationExecute(r ApiSlurmdbV0040GetAssociationRequest) (*V0040OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040GetAssociationsRequest) Account(account string) ApiSlurmdbV0040GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040GetAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0040GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetAssociationsRequest) Format(format string) ApiSlurmdbV0040GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040GetAssociationsRequest) Id(id string) ApiSlurmdbV0040GetAssociationsRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040GetAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040GetAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040GetAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040GetAssociationsRequest) Partition(partition string) ApiSlurmdbV0040GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationsRequest) Qos(qos string) ApiSlurmdbV0040GetAssociationsRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040GetAssociationsRequest) User(user string) ApiSlurmdbV0040GetAssociationsRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040GetAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040GetAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040GetAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040GetAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040GetAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040GetAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040GetAssociationsRequest) Execute() (*V0040OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAssociationsExecute(r)
}

/*
SlurmdbV0040GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociations(ctx context.Context) ApiSlurmdbV0040GetAssociationsRequest {
	return ApiSlurmdbV0040GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociationsExecute(r ApiSlurmdbV0040GetAssociationsRequest) (*V0040OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0040GetClusterRequest) Classification(classification string) ApiSlurmdbV0040GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040GetClusterRequest) Cluster(cluster string) ApiSlurmdbV0040GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0040GetClusterRequest) Federation(federation string) ApiSlurmdbV0040GetClusterRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0040GetClusterRequest) Flags(flags string) ApiSlurmdbV0040GetClusterRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetClusterRequest) Format(format string) ApiSlurmdbV0040GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0040GetClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0040GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0040GetClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0040GetClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0040GetClusterRequest) Execute() (*V0040OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetClusterExecute(r)
}

/*
SlurmdbV0040GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0040GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetCluster(ctx context.Context, clusterName string) ApiSlurmdbV0040GetClusterRequest {
	return ApiSlurmdbV0040GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetClusterExecute(r ApiSlurmdbV0040GetClusterRequest) (*V0040OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
}

// Filter reservations since update timestamp
func (r ApiSlurmdbV0040GetClustersRequest) UpdateTime(updateTime string) ApiSlurmdbV0040GetClustersRequest {
	r.updateTime = &updateTime
	return r
}

func (r ApiSlurmdbV0040GetClustersRequest) Execute() (*V0040OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetClustersExecute(r)
}

/*
SlurmdbV0040GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetClusters(ctx context.Context) ApiSlurmdbV0040GetClustersRequest {
	return ApiSlurmdbV0040GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetClustersExecute(r ApiSlurmdbV0040GetClustersRequest) (*V0040OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0040GetConfigRequest) Execute() (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetConfigExecute(r)
}

/*
SlurmdbV0040GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetConfig(ctx context.Context) ApiSlurmdbV0040GetConfigRequest {
	return ApiSlurmdbV0040GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0040GetConfigExecute(r ApiSlurmdbV0040GetConfigRequest) (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdConfigResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetDiagRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0040GetDiagRequest) Execute() (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetDiagExecute(r)
}

/*
SlurmdbV0040GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetDiag(ctx context.Context) ApiSlurmdbV0040GetDiagRequest {
	return ApiSlurmdbV0040GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdStatsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetDiagExecute(r ApiSlurmdbV0040GetDiagRequest) (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/diag/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdStatsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetInstanceRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r ApiSlurmdbV0040GetInstanceRequest) Cluster(cluster string) ApiSlurmdbV0040GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r ApiSlurmdbV0040GetInstanceRequest) Extra(extra string) ApiSlurmdbV0040GetInstanceRequest {
	r.extra = &extra
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetInstanceRequest) Format(format string) ApiSlurmdbV0040GetInstanceRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r ApiSlurmdbV0040GetInstanceRequest) InstanceId(instanceId string) ApiSlurmdbV0040GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r ApiSlurmdbV0040GetInstanceRequest) InstanceType(instanceType string) ApiSlurmdbV0040GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

// ranged node string
func (r ApiSlurmdbV0040GetInstanceRequest) NodeList(nodeList string) ApiSlurmdbV0040GetInstanceRequest {
	r.nodeList = &nodeList
	return r
}

// time end UNIX timestamp
func (r ApiSlurmdbV0040GetInstanceRequest) TimeEnd(timeEnd string) ApiSlurmdbV0040GetInstanceRequest {
	r.timeEnd = &timeEnd
	return r
}

// time start UNIX timestamp
func (r ApiSlurmdbV0040GetInstanceRequest) TimeStart(timeStart string) ApiSlurmdbV0040GetInstanceRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiSlurmdbV0040GetInstanceRequest) Execute() (*V0040OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetInstanceExecute(r)
}

/*
SlurmdbV0040GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetInstance(ctx context.Context) ApiSlurmdbV0040GetInstanceRequest {
	return ApiSlurmdbV0040GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0040GetInstanceExecute(r ApiSlurmdbV0040GetInstanceRequest) (*V0040OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetInstancesRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r ApiSlurmdbV0040GetInstancesRequest) Cluster(cluster string) ApiSlurmdbV0040GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r ApiSlurmdbV0040GetInstancesRequest) Extra(extra string) ApiSlurmdbV0040GetInstancesRequest {
	r.extra = &extra
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetInstancesRequest) Format(format string) ApiSlurmdbV0040GetInstancesRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r ApiSlurmdbV0040GetInstancesRequest) InstanceId(instanceId string) ApiSlurmdbV0040GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r ApiSlurmdbV0040GetInstancesRequest) InstanceType(instanceType string) ApiSlurmdbV0040GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

// ranged node string
func (r ApiSlurmdbV0040GetInstancesRequest) NodeList(nodeList string) ApiSlurmdbV0040GetInstancesRequest {
	r.nodeList = &nodeList
	return r
}

// time end UNIX timestamp
func (r ApiSlurmdbV0040GetInstancesRequest) TimeEnd(timeEnd string) ApiSlurmdbV0040GetInstancesRequest {
	r.timeEnd = &timeEnd
	return r
}

// time start UNIX timestamp
func (r ApiSlurmdbV0040GetInstancesRequest) TimeStart(timeStart string) ApiSlurmdbV0040GetInstancesRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiSlurmdbV0040GetInstancesRequest) Execute() (*V0040OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetInstancesExecute(r)
}

/*
SlurmdbV0040GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetInstances(ctx context.Context) ApiSlurmdbV0040GetInstancesRequest {
	return ApiSlurmdbV0040GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0040GetInstancesExecute(r ApiSlurmdbV0040GetInstancesRequest) (*V0040OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetJobRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	jobId string
}

func (r ApiSlurmdbV0040GetJobRequest) Execute() (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetJobExecute(r)
}

/*
SlurmdbV0040GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job id
 @return ApiSlurmdbV0040GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetJob(ctx context.Context, jobId string) ApiSlurmdbV0040GetJobRequest {
	return ApiSlurmdbV0040GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetJobExecute(r ApiSlurmdbV0040GetJobRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetJobsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	association *string
	cluster *string
	constraints *string
	cpusMax *string
	cpusMin *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	nodesMax *string
	nodesMin *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	timelimitMax *string
	timelimitMin *string
	endTime *string
	startTime *string
	submitTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r ApiSlurmdbV0040GetJobsRequest) Account(account string) ApiSlurmdbV0040GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r ApiSlurmdbV0040GetJobsRequest) Association(association string) ApiSlurmdbV0040GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040GetJobsRequest) Cluster(cluster string) ApiSlurmdbV0040GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r ApiSlurmdbV0040GetJobsRequest) Constraints(constraints string) ApiSlurmdbV0040GetJobsRequest {
	r.constraints = &constraints
	return r
}

// number of cpus high range
func (r ApiSlurmdbV0040GetJobsRequest) CpusMax(cpusMax string) ApiSlurmdbV0040GetJobsRequest {
	r.cpusMax = &cpusMax
	return r
}

// number of cpus low range
func (r ApiSlurmdbV0040GetJobsRequest) CpusMin(cpusMin string) ApiSlurmdbV0040GetJobsRequest {
	r.cpusMin = &cpusMin
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) SchedulerUnset(schedulerUnset string) ApiSlurmdbV0040GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) ApiSlurmdbV0040GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ScheduledByMain(scheduledByMain string) ApiSlurmdbV0040GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) ApiSlurmdbV0040GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) JobStarted(jobStarted string) ApiSlurmdbV0040GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// job exit code (numeric)
func (r ApiSlurmdbV0040GetJobsRequest) ExitCode(exitCode string) ApiSlurmdbV0040GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ShowDuplicates(showDuplicates string) ApiSlurmdbV0040GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) SkipSteps(skipSteps string) ApiSlurmdbV0040GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) ApiSlurmdbV0040GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) WholeHetjob(wholeHetjob string) ApiSlurmdbV0040GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) ApiSlurmdbV0040GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) DisableWaitForResult(disableWaitForResult string) ApiSlurmdbV0040GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) ApiSlurmdbV0040GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ShowBatchScript(showBatchScript string) ApiSlurmdbV0040GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) ApiSlurmdbV0040GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetJobsRequest) Format(format string) ApiSlurmdbV0040GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r ApiSlurmdbV0040GetJobsRequest) Groups(groups string) ApiSlurmdbV0040GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r ApiSlurmdbV0040GetJobsRequest) JobName(jobName string) ApiSlurmdbV0040GetJobsRequest {
	r.jobName = &jobName
	return r
}

// number of nodes high range
func (r ApiSlurmdbV0040GetJobsRequest) NodesMax(nodesMax string) ApiSlurmdbV0040GetJobsRequest {
	r.nodesMax = &nodesMax
	return r
}

// number of nodes low range
func (r ApiSlurmdbV0040GetJobsRequest) NodesMin(nodesMin string) ApiSlurmdbV0040GetJobsRequest {
	r.nodesMin = &nodesMin
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040GetJobsRequest) Partition(partition string) ApiSlurmdbV0040GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0040GetJobsRequest) Qos(qos string) ApiSlurmdbV0040GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r ApiSlurmdbV0040GetJobsRequest) Reason(reason string) ApiSlurmdbV0040GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r ApiSlurmdbV0040GetJobsRequest) Reservation(reservation string) ApiSlurmdbV0040GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r ApiSlurmdbV0040GetJobsRequest) ReservationId(reservationId string) ApiSlurmdbV0040GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r ApiSlurmdbV0040GetJobsRequest) State(state string) ApiSlurmdbV0040GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r ApiSlurmdbV0040GetJobsRequest) Step(step string) ApiSlurmdbV0040GetJobsRequest {
	r.step = &step
	return r
}

// maximum timelimit (seconds)
func (r ApiSlurmdbV0040GetJobsRequest) TimelimitMax(timelimitMax string) ApiSlurmdbV0040GetJobsRequest {
	r.timelimitMax = &timelimitMax
	return r
}

// minimum timelimit (seconds)
func (r ApiSlurmdbV0040GetJobsRequest) TimelimitMin(timelimitMin string) ApiSlurmdbV0040GetJobsRequest {
	r.timelimitMin = &timelimitMin
	return r
}

// usage end timestamp
func (r ApiSlurmdbV0040GetJobsRequest) EndTime(endTime string) ApiSlurmdbV0040GetJobsRequest {
	r.endTime = &endTime
	return r
}

// usage start timestamp
func (r ApiSlurmdbV0040GetJobsRequest) StartTime(startTime string) ApiSlurmdbV0040GetJobsRequest {
	r.startTime = &startTime
	return r
}

// submit time timestamp
func (r ApiSlurmdbV0040GetJobsRequest) SubmitTime(submitTime string) ApiSlurmdbV0040GetJobsRequest {
	r.submitTime = &submitTime
	return r
}

// ranged node string where jobs ran
func (r ApiSlurmdbV0040GetJobsRequest) Node(node string) ApiSlurmdbV0040GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r ApiSlurmdbV0040GetJobsRequest) Users(users string) ApiSlurmdbV0040GetJobsRequest {
	r.users = &users
	return r
}

// CSV wckey list
func (r ApiSlurmdbV0040GetJobsRequest) Wckey(wckey string) ApiSlurmdbV0040GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) Execute() (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetJobsExecute(r)
}

/*
SlurmdbV0040GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetJobs(ctx context.Context) ApiSlurmdbV0040GetJobsRequest {
	return ApiSlurmdbV0040GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetJobsExecute(r ApiSlurmdbV0040GetJobsRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "")
	}
	if r.cpusMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpus_max", r.cpusMax, "")
	}
	if r.cpusMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpus_min", r.cpusMin, "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "")
	}
	if r.nodesMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_max", r.nodesMax, "")
	}
	if r.nodesMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_min", r.nodesMin, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "")
	}
	if r.timelimitMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timelimit_max", r.timelimitMax, "")
	}
	if r.timelimitMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timelimit_min", r.timelimitMin, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "")
	}
	if r.submitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "submit_time", r.submitTime, "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
}

// CSV description list
func (r ApiSlurmdbV0040GetQosRequest) Description(description string) ApiSlurmdbV0040GetQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0040GetQosRequest) Id(id string) ApiSlurmdbV0040GetQosRequest {
	r.id = &id
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetQosRequest) Format(format string) ApiSlurmdbV0040GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0040GetQosRequest) Name(name string) ApiSlurmdbV0040GetQosRequest {
	r.name = &name
	return r
}

func (r ApiSlurmdbV0040GetQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0040GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0040GetQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetQosRequest) Execute() (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetQosExecute(r)
}

/*
SlurmdbV0040GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetQos(ctx context.Context) ApiSlurmdbV0040GetQosRequest {
	return ApiSlurmdbV0040GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0040GetQosExecute(r ApiSlurmdbV0040GetQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r ApiSlurmdbV0040GetSingleQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetSingleQosRequest) Execute() (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetSingleQosExecute(r)
}

/*
SlurmdbV0040GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0040GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetSingleQos(ctx context.Context, qos string) ApiSlurmdbV0040GetSingleQosRequest {
	return ApiSlurmdbV0040GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0040GetSingleQosExecute(r ApiSlurmdbV0040GetSingleQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0040GetTresRequest) Execute() (*V0040OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetTresExecute(r)
}

/*
SlurmdbV0040GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetTres(ctx context.Context) ApiSlurmdbV0040GetTresRequest {
	return ApiSlurmdbV0040GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0040GetTresExecute(r ApiSlurmdbV0040GetTresRequest) (*V0040OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiTresResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r ApiSlurmdbV0040GetUserRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include assocations
func (r ApiSlurmdbV0040GetUserRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r ApiSlurmdbV0040GetUserRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include wckeys
func (r ApiSlurmdbV0040GetUserRequest) WithWckeys(withWckeys string) ApiSlurmdbV0040GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r ApiSlurmdbV0040GetUserRequest) Execute() (*V0040OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetUserExecute(r)
}

/*
SlurmdbV0040GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0040GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetUser(ctx context.Context, name string) ApiSlurmdbV0040GetUserRequest {
	return ApiSlurmdbV0040GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetUserExecute(r ApiSlurmdbV0040GetUserRequest) (*V0040OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r ApiSlurmdbV0040GetUsersRequest) AdminLevel(adminLevel string) ApiSlurmdbV0040GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r ApiSlurmdbV0040GetUsersRequest) DefaultAccount(defaultAccount string) ApiSlurmdbV0040GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default wckey list
func (r ApiSlurmdbV0040GetUsersRequest) DefaultWckey(defaultWckey string) ApiSlurmdbV0040GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r ApiSlurmdbV0040GetUsersRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r ApiSlurmdbV0040GetUsersRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r ApiSlurmdbV0040GetUsersRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With wckeys
func (r ApiSlurmdbV0040GetUsersRequest) WithWckeys(withWckeys string) ApiSlurmdbV0040GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r ApiSlurmdbV0040GetUsersRequest) WithoutDefaults(withoutDefaults string) ApiSlurmdbV0040GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r ApiSlurmdbV0040GetUsersRequest) Execute() (*V0040OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetUsersExecute(r)
}

/*
SlurmdbV0040GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetUsers(ctx context.Context) ApiSlurmdbV0040GetUsersRequest {
	return ApiSlurmdbV0040GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetUsersExecute(r ApiSlurmdbV0040GetUsersRequest) (*V0040OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0040GetWckeyRequest) Execute() (*V0040OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetWckeyExecute(r)
}

/*
SlurmdbV0040GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0040GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetWckey(ctx context.Context, id string) ApiSlurmdbV0040GetWckeyRequest {
	return ApiSlurmdbV0040GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeyExecute(r ApiSlurmdbV0040GetWckeyRequest) (*V0040OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r ApiSlurmdbV0040GetWckeysRequest) Cluster(cluster string) ApiSlurmdbV0040GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// CSV format name list
func (r ApiSlurmdbV0040GetWckeysRequest) Format(format string) ApiSlurmdbV0040GetWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040GetWckeysRequest) Id(id string) ApiSlurmdbV0040GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0040GetWckeysRequest) Name(name string) ApiSlurmdbV0040GetWckeysRequest {
	r.name = &name
	return r
}

// only query defaults
func (r ApiSlurmdbV0040GetWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040GetWckeysRequest) User(user string) ApiSlurmdbV0040GetWckeysRequest {
	r.user = &user
	return r
}

// include usage with query
func (r ApiSlurmdbV0040GetWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// include deleted wckeys with query
func (r ApiSlurmdbV0040GetWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetWckeysRequest) Execute() (*V0040OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetWckeysExecute(r)
}

/*
SlurmdbV0040GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeys(ctx context.Context) ApiSlurmdbV0040GetWckeysRequest {
	return ApiSlurmdbV0040GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeysExecute(r ApiSlurmdbV0040GetWckeysRequest) (*V0040OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiAccountsResp *V0040OpenapiAccountsResp
}

// Description of accounts to update/create
func (r ApiSlurmdbV0040PostAccountsRequest) V0040OpenapiAccountsResp(v0040OpenapiAccountsResp V0040OpenapiAccountsResp) ApiSlurmdbV0040PostAccountsRequest {
	r.v0040OpenapiAccountsResp = &v0040OpenapiAccountsResp
	return r
}

func (r ApiSlurmdbV0040PostAccountsRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAccountsExecute(r)
}

/*
SlurmdbV0040PostAccounts Add/update list of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAccounts(ctx context.Context) ApiSlurmdbV0040PostAccountsRequest {
	return ApiSlurmdbV0040PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsExecute(r ApiSlurmdbV0040PostAccountsRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiAccountsAddCondResp *V0040OpenapiAccountsAddCondResp
}

// Add list of accounts with conditional association
func (r ApiSlurmdbV0040PostAccountsAssociationRequest) V0040OpenapiAccountsAddCondResp(v0040OpenapiAccountsAddCondResp V0040OpenapiAccountsAddCondResp) ApiSlurmdbV0040PostAccountsAssociationRequest {
	r.v0040OpenapiAccountsAddCondResp = &v0040OpenapiAccountsAddCondResp
	return r
}

func (r ApiSlurmdbV0040PostAccountsAssociationRequest) Execute() (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0040PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsAssociation(ctx context.Context) ApiSlurmdbV0040PostAccountsAssociationRequest {
	return ApiSlurmdbV0040PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsAssociationExecute(r ApiSlurmdbV0040PostAccountsAssociationRequest) (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAccountsAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiAssocsResp *V0040OpenapiAssocsResp
}

// Job description
func (r ApiSlurmdbV0040PostAssociationsRequest) V0040OpenapiAssocsResp(v0040OpenapiAssocsResp V0040OpenapiAssocsResp) ApiSlurmdbV0040PostAssociationsRequest {
	r.v0040OpenapiAssocsResp = &v0040OpenapiAssocsResp
	return r
}

func (r ApiSlurmdbV0040PostAssociationsRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAssociationsExecute(r)
}

/*
SlurmdbV0040PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAssociations(ctx context.Context) ApiSlurmdbV0040PostAssociationsRequest {
	return ApiSlurmdbV0040PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostAssociationsExecute(r ApiSlurmdbV0040PostAssociationsRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
	v0040OpenapiClustersResp *V0040OpenapiClustersResp
}

// Filter reservations since update timestamp
func (r ApiSlurmdbV0040PostClustersRequest) UpdateTime(updateTime string) ApiSlurmdbV0040PostClustersRequest {
	r.updateTime = &updateTime
	return r
}

// Cluster add or update descriptions
func (r ApiSlurmdbV0040PostClustersRequest) V0040OpenapiClustersResp(v0040OpenapiClustersResp V0040OpenapiClustersResp) ApiSlurmdbV0040PostClustersRequest {
	r.v0040OpenapiClustersResp = &v0040OpenapiClustersResp
	return r
}

func (r ApiSlurmdbV0040PostClustersRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostClustersExecute(r)
}

/*
SlurmdbV0040PostClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostClusters(ctx context.Context) ApiSlurmdbV0040PostClustersRequest {
	return ApiSlurmdbV0040PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostClustersExecute(r ApiSlurmdbV0040PostClustersRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiSlurmdbdConfigResp *V0040OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r ApiSlurmdbV0040PostConfigRequest) V0040OpenapiSlurmdbdConfigResp(v0040OpenapiSlurmdbdConfigResp V0040OpenapiSlurmdbdConfigResp) ApiSlurmdbV0040PostConfigRequest {
	r.v0040OpenapiSlurmdbdConfigResp = &v0040OpenapiSlurmdbdConfigResp
	return r
}

func (r ApiSlurmdbV0040PostConfigRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostConfigExecute(r)
}

/*
SlurmdbV0040PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostConfig(ctx context.Context) ApiSlurmdbV0040PostConfigRequest {
	return ApiSlurmdbV0040PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostConfigExecute(r ApiSlurmdbV0040PostConfigRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
	v0040OpenapiSlurmdbdQosResp *V0040OpenapiSlurmdbdQosResp
}

// CSV description list
func (r ApiSlurmdbV0040PostQosRequest) Description(description string) ApiSlurmdbV0040PostQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0040PostQosRequest) Id(id string) ApiSlurmdbV0040PostQosRequest {
	r.id = &id
	return r
}

// CSV format list
func (r ApiSlurmdbV0040PostQosRequest) Format(format string) ApiSlurmdbV0040PostQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0040PostQosRequest) Name(name string) ApiSlurmdbV0040PostQosRequest {
	r.name = &name
	return r
}

func (r ApiSlurmdbV0040PostQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0040PostQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0040PostQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040PostQosRequest {
	r.withDeleted = &withDeleted
	return r
}

// Description of QOS to add or update
func (r ApiSlurmdbV0040PostQosRequest) V0040OpenapiSlurmdbdQosResp(v0040OpenapiSlurmdbdQosResp V0040OpenapiSlurmdbdQosResp) ApiSlurmdbV0040PostQosRequest {
	r.v0040OpenapiSlurmdbdQosResp = &v0040OpenapiSlurmdbdQosResp
	return r
}

func (r ApiSlurmdbV0040PostQosRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostQosExecute(r)
}

/*
SlurmdbV0040PostQos Add or update QOSs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostQos(ctx context.Context) ApiSlurmdbV0040PostQosRequest {
	return ApiSlurmdbV0040PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostQosExecute(r ApiSlurmdbV0040PostQosRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiTresResp *V0040OpenapiTresResp
}

// TRES descriptions. Only works in developer mode.
func (r ApiSlurmdbV0040PostTresRequest) V0040OpenapiTresResp(v0040OpenapiTresResp V0040OpenapiTresResp) ApiSlurmdbV0040PostTresRequest {
	r.v0040OpenapiTresResp = &v0040OpenapiTresResp
	return r
}

func (r ApiSlurmdbV0040PostTresRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostTresExecute(r)
}

/*
SlurmdbV0040PostTres Add TRES

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostTres(ctx context.Context) ApiSlurmdbV0040PostTresRequest {
	return ApiSlurmdbV0040PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostTresExecute(r ApiSlurmdbV0040PostTresRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiUsersResp *V0040OpenapiUsersResp
}

// add or update user
func (r ApiSlurmdbV0040PostUsersRequest) V0040OpenapiUsersResp(v0040OpenapiUsersResp V0040OpenapiUsersResp) ApiSlurmdbV0040PostUsersRequest {
	r.v0040OpenapiUsersResp = &v0040OpenapiUsersResp
	return r
}

func (r ApiSlurmdbV0040PostUsersRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostUsersExecute(r)
}

/*
SlurmdbV0040PostUsers Update users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostUsers(ctx context.Context) ApiSlurmdbV0040PostUsersRequest {
	return ApiSlurmdbV0040PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersExecute(r ApiSlurmdbV0040PostUsersRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
	flags *string
	v0040OpenapiUsersAddCondResp *V0040OpenapiUsersAddCondResp
}

// Filter partitions since update timestamp
func (r ApiSlurmdbV0040PostUsersAssociationRequest) UpdateTime(updateTime string) ApiSlurmdbV0040PostUsersAssociationRequest {
	r.updateTime = &updateTime
	return r
}

// Query flags
func (r ApiSlurmdbV0040PostUsersAssociationRequest) Flags(flags string) ApiSlurmdbV0040PostUsersAssociationRequest {
	r.flags = &flags
	return r
}

// Create users with conditional association
func (r ApiSlurmdbV0040PostUsersAssociationRequest) V0040OpenapiUsersAddCondResp(v0040OpenapiUsersAddCondResp V0040OpenapiUsersAddCondResp) ApiSlurmdbV0040PostUsersAssociationRequest {
	r.v0040OpenapiUsersAddCondResp = &v0040OpenapiUsersAddCondResp
	return r
}

func (r ApiSlurmdbV0040PostUsersAssociationRequest) Execute() (*V0040OpenapiUsersAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostUsersAssociationExecute(r)
}

/*
SlurmdbV0040PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersAssociation(ctx context.Context) ApiSlurmdbV0040PostUsersAssociationRequest {
	return ApiSlurmdbV0040PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersAssociationExecute(r ApiSlurmdbV0040PostUsersAssociationRequest) (*V0040OpenapiUsersAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiUsersAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	v0040OpenapiWckeyResp *V0040OpenapiWckeyResp
}

// CSV cluster name list
func (r ApiSlurmdbV0040PostWckeysRequest) Cluster(cluster string) ApiSlurmdbV0040PostWckeysRequest {
	r.cluster = &cluster
	return r
}

// CSV format name list
func (r ApiSlurmdbV0040PostWckeysRequest) Format(format string) ApiSlurmdbV0040PostWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040PostWckeysRequest) Id(id string) ApiSlurmdbV0040PostWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0040PostWckeysRequest) Name(name string) ApiSlurmdbV0040PostWckeysRequest {
	r.name = &name
	return r
}

// only query defaults
func (r ApiSlurmdbV0040PostWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040PostWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040PostWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040PostWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040PostWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0040PostWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040PostWckeysRequest) User(user string) ApiSlurmdbV0040PostWckeysRequest {
	r.user = &user
	return r
}

// include usage with query
func (r ApiSlurmdbV0040PostWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0040PostWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// include deleted wckeys with query
func (r ApiSlurmdbV0040PostWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040PostWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

// wckeys description
func (r ApiSlurmdbV0040PostWckeysRequest) V0040OpenapiWckeyResp(v0040OpenapiWckeyResp V0040OpenapiWckeyResp) ApiSlurmdbV0040PostWckeysRequest {
	r.v0040OpenapiWckeyResp = &v0040OpenapiWckeyResp
	return r
}

func (r ApiSlurmdbV0040PostWckeysRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostWckeysExecute(r)
}

/*
SlurmdbV0040PostWckeys Add or update wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostWckeys(ctx context.Context) ApiSlurmdbV0040PostWckeysRequest {
	return ApiSlurmdbV0040PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostWckeysExecute(r ApiSlurmdbV0040PostWckeysRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
}

func (r ApiSlurmdbV0041DeleteAccountRequest) Execute() (*V0041OpenapiAccountsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAccountExecute(r)
}

/*
SlurmdbV0041DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0041DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string) ApiSlurmdbV0041DeleteAccountRequest {
	return ApiSlurmdbV0041DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAccountExecute(r ApiSlurmdbV0041DeleteAccountRequest) (*V0041OpenapiAccountsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Account(account string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Cluster(cluster string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Format(format string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Id(id string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0041DeleteAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041DeleteAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Partition(partition string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationRequest) Qos(qos string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0041DeleteAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0041DeleteAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041DeleteAssociationRequest) User(user string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0041DeleteAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041DeleteAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041DeleteAssociationRequest) Execute() (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAssociationExecute(r)
}

/*
SlurmdbV0041DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociation(ctx context.Context) ApiSlurmdbV0041DeleteAssociationRequest {
	return ApiSlurmdbV0041DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociationExecute(r ApiSlurmdbV0041DeleteAssociationRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Account(account string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Format(format string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Id(id string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0041DeleteAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041DeleteAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Partition(partition string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) Qos(qos string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0041DeleteAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0041DeleteAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041DeleteAssociationsRequest) User(user string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0041DeleteAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041DeleteAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041DeleteAssociationsRequest) Execute() (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAssociationsExecute(r)
}

/*
SlurmdbV0041DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociations(ctx context.Context) ApiSlurmdbV0041DeleteAssociationsRequest {
	return ApiSlurmdbV0041DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociationsExecute(r ApiSlurmdbV0041DeleteAssociationsRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0041DeleteClusterRequest) Classification(classification string) ApiSlurmdbV0041DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0041DeleteClusterRequest) Cluster(cluster string) ApiSlurmdbV0041DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0041DeleteClusterRequest) Federation(federation string) ApiSlurmdbV0041DeleteClusterRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0041DeleteClusterRequest) Flags(flags string) ApiSlurmdbV0041DeleteClusterRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0041DeleteClusterRequest) Format(format string) ApiSlurmdbV0041DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0041DeleteClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0041DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0041DeleteClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0041DeleteClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0041DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0041DeleteClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0041DeleteClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0041DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0041DeleteClusterRequest) Execute() (*V0041OpenapiClustersRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteClusterExecute(r)
}

/*
SlurmdbV0041DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0041DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string) ApiSlurmdbV0041DeleteClusterRequest {
	return ApiSlurmdbV0041DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteClusterExecute(r ApiSlurmdbV0041DeleteClusterRequest) (*V0041OpenapiClustersRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
}

func (r ApiSlurmdbV0041DeleteSingleQosRequest) Execute() (*V0041OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteSingleQosExecute(r)
}

/*
SlurmdbV0041DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0041DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string) ApiSlurmdbV0041DeleteSingleQosRequest {
	return ApiSlurmdbV0041DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteSingleQosExecute(r ApiSlurmdbV0041DeleteSingleQosRequest) (*V0041OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
}

func (r ApiSlurmdbV0041DeleteUserRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteUserExecute(r)
}

/*
SlurmdbV0041DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0041DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteUser(ctx context.Context, name string) ApiSlurmdbV0041DeleteUserRequest {
	return ApiSlurmdbV0041DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteUserExecute(r ApiSlurmdbV0041DeleteUserRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041DeleteWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0041DeleteWckeyRequest) Execute() (*V0041OpenapiWckeyRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteWckeyExecute(r)
}

/*
SlurmdbV0041DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0041DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteWckey(ctx context.Context, id string) ApiSlurmdbV0041DeleteWckeyRequest {
	return ApiSlurmdbV0041DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteWckeyExecute(r ApiSlurmdbV0041DeleteWckeyRequest) (*V0041OpenapiWckeyRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// include associations
func (r ApiSlurmdbV0041GetAccountRequest) WithAssocs(withAssocs string) ApiSlurmdbV0041GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// include coordinators
func (r ApiSlurmdbV0041GetAccountRequest) WithCoords(withCoords string) ApiSlurmdbV0041GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// include deleted
func (r ApiSlurmdbV0041GetAccountRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetAccountRequest) Execute() (*V0041OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAccountExecute(r)
}

/*
SlurmdbV0041GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0041GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAccount(ctx context.Context, accountName string) ApiSlurmdbV0041GetAccountRequest {
	return ApiSlurmdbV0041GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAccountExecute(r ApiSlurmdbV0041GetAccountRequest) (*V0041OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	dELETED *string
	withAssociations *string
	withCoordinators *string
	noUsersAreCoords *string
	usersAreCoords *string
}

// CSV description list
func (r ApiSlurmdbV0041GetAccountsRequest) Description(description string) ApiSlurmdbV0041GetAccountsRequest {
	r.description = &description
	return r
}

// include deleted assocations
func (r ApiSlurmdbV0041GetAccountsRequest) DELETED(dELETED string) ApiSlurmdbV0041GetAccountsRequest {
	r.dELETED = &dELETED
	return r
}

// query includes associations
func (r ApiSlurmdbV0041GetAccountsRequest) WithAssociations(withAssociations string) ApiSlurmdbV0041GetAccountsRequest {
	r.withAssociations = &withAssociations
	return r
}

// query includes coordinators
func (r ApiSlurmdbV0041GetAccountsRequest) WithCoordinators(withCoordinators string) ApiSlurmdbV0041GetAccountsRequest {
	r.withCoordinators = &withCoordinators
	return r
}

// remove users as coordinators
func (r ApiSlurmdbV0041GetAccountsRequest) NoUsersAreCoords(noUsersAreCoords string) ApiSlurmdbV0041GetAccountsRequest {
	r.noUsersAreCoords = &noUsersAreCoords
	return r
}

// users are coordinators
func (r ApiSlurmdbV0041GetAccountsRequest) UsersAreCoords(usersAreCoords string) ApiSlurmdbV0041GetAccountsRequest {
	r.usersAreCoords = &usersAreCoords
	return r
}

func (r ApiSlurmdbV0041GetAccountsRequest) Execute() (*V0041OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAccountsExecute(r)
}

/*
SlurmdbV0041GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAccounts(ctx context.Context) ApiSlurmdbV0041GetAccountsRequest {
	return ApiSlurmdbV0041GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAccountsExecute(r ApiSlurmdbV0041GetAccountsRequest) (*V0041OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.dELETED != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DELETED", r.dELETED, "")
	}
	if r.withAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithAssociations", r.withAssociations, "")
	}
	if r.withCoordinators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithCoordinators", r.withCoordinators, "")
	}
	if r.noUsersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NoUsersAreCoords", r.noUsersAreCoords, "")
	}
	if r.usersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UsersAreCoords", r.usersAreCoords, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041GetAssociationRequest) Account(account string) ApiSlurmdbV0041GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041GetAssociationRequest) Cluster(cluster string) ApiSlurmdbV0041GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetAssociationRequest) Format(format string) ApiSlurmdbV0041GetAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041GetAssociationRequest) Id(id string) ApiSlurmdbV0041GetAssociationRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0041GetAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041GetAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041GetAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041GetAssociationRequest) Partition(partition string) ApiSlurmdbV0041GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationRequest) Qos(qos string) ApiSlurmdbV0041GetAssociationRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0041GetAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0041GetAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041GetAssociationRequest) User(user string) ApiSlurmdbV0041GetAssociationRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0041GetAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0041GetAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0041GetAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041GetAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0041GetAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041GetAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0041GetAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041GetAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0041GetAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041GetAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041GetAssociationRequest) Execute() (*V0041OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAssociationExecute(r)
}

/*
SlurmdbV0041GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociation(ctx context.Context) ApiSlurmdbV0041GetAssociationRequest {
	return ApiSlurmdbV0041GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociationExecute(r ApiSlurmdbV0041GetAssociationRequest) (*V0041OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0041GetAssociationsRequest) Account(account string) ApiSlurmdbV0041GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0041GetAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0041GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0041GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetAssociationsRequest) Format(format string) ApiSlurmdbV0041GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041GetAssociationsRequest) Id(id string) ApiSlurmdbV0041GetAssociationsRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0041GetAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041GetAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0041GetAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0041GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041GetAssociationsRequest) Partition(partition string) ApiSlurmdbV0041GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0041GetAssociationsRequest) Qos(qos string) ApiSlurmdbV0041GetAssociationsRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0041GetAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0041GetAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041GetAssociationsRequest) User(user string) ApiSlurmdbV0041GetAssociationsRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0041GetAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0041GetAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0041GetAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0041GetAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0041GetAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0041GetAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0041GetAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0041GetAssociationsRequest) Execute() (*V0041OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAssociationsExecute(r)
}

/*
SlurmdbV0041GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociations(ctx context.Context) ApiSlurmdbV0041GetAssociationsRequest {
	return ApiSlurmdbV0041GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociationsExecute(r ApiSlurmdbV0041GetAssociationsRequest) (*V0041OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0041GetClusterRequest) Classification(classification string) ApiSlurmdbV0041GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0041GetClusterRequest) Cluster(cluster string) ApiSlurmdbV0041GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0041GetClusterRequest) Federation(federation string) ApiSlurmdbV0041GetClusterRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0041GetClusterRequest) Flags(flags string) ApiSlurmdbV0041GetClusterRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetClusterRequest) Format(format string) ApiSlurmdbV0041GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0041GetClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0041GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0041GetClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0041GetClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0041GetClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0041GetClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0041GetClusterRequest) Execute() (*V0041OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetClusterExecute(r)
}

/*
SlurmdbV0041GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0041GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetCluster(ctx context.Context, clusterName string) ApiSlurmdbV0041GetClusterRequest {
	return ApiSlurmdbV0041GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetClusterExecute(r ApiSlurmdbV0041GetClusterRequest) (*V0041OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
}

// Filter reservations since update timestamp
func (r ApiSlurmdbV0041GetClustersRequest) UpdateTime(updateTime string) ApiSlurmdbV0041GetClustersRequest {
	r.updateTime = &updateTime
	return r
}

func (r ApiSlurmdbV0041GetClustersRequest) Execute() (*V0041OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetClustersExecute(r)
}

/*
SlurmdbV0041GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetClusters(ctx context.Context) ApiSlurmdbV0041GetClustersRequest {
	return ApiSlurmdbV0041GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetClustersExecute(r ApiSlurmdbV0041GetClustersRequest) (*V0041OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0041GetConfigRequest) Execute() (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetConfigExecute(r)
}

/*
SlurmdbV0041GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetConfig(ctx context.Context) ApiSlurmdbV0041GetConfigRequest {
	return ApiSlurmdbV0041GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0041GetConfigExecute(r ApiSlurmdbV0041GetConfigRequest) (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdConfigResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetDiagRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0041GetDiagRequest) Execute() (*V0041OpenapiSlurmdbdStatsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetDiagExecute(r)
}

/*
SlurmdbV0041GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetDiag(ctx context.Context) ApiSlurmdbV0041GetDiagRequest {
	return ApiSlurmdbV0041GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdStatsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetDiagExecute(r ApiSlurmdbV0041GetDiagRequest) (*V0041OpenapiSlurmdbdStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/diag/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdStatsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetInstanceRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r ApiSlurmdbV0041GetInstanceRequest) Cluster(cluster string) ApiSlurmdbV0041GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r ApiSlurmdbV0041GetInstanceRequest) Extra(extra string) ApiSlurmdbV0041GetInstanceRequest {
	r.extra = &extra
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetInstanceRequest) Format(format string) ApiSlurmdbV0041GetInstanceRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r ApiSlurmdbV0041GetInstanceRequest) InstanceId(instanceId string) ApiSlurmdbV0041GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r ApiSlurmdbV0041GetInstanceRequest) InstanceType(instanceType string) ApiSlurmdbV0041GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

// ranged node string
func (r ApiSlurmdbV0041GetInstanceRequest) NodeList(nodeList string) ApiSlurmdbV0041GetInstanceRequest {
	r.nodeList = &nodeList
	return r
}

// time end UNIX timestamp
func (r ApiSlurmdbV0041GetInstanceRequest) TimeEnd(timeEnd string) ApiSlurmdbV0041GetInstanceRequest {
	r.timeEnd = &timeEnd
	return r
}

// time start UNIX timestamp
func (r ApiSlurmdbV0041GetInstanceRequest) TimeStart(timeStart string) ApiSlurmdbV0041GetInstanceRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiSlurmdbV0041GetInstanceRequest) Execute() (*V0041OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetInstanceExecute(r)
}

/*
SlurmdbV0041GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetInstance(ctx context.Context) ApiSlurmdbV0041GetInstanceRequest {
	return ApiSlurmdbV0041GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0041GetInstanceExecute(r ApiSlurmdbV0041GetInstanceRequest) (*V0041OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetInstancesRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r ApiSlurmdbV0041GetInstancesRequest) Cluster(cluster string) ApiSlurmdbV0041GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r ApiSlurmdbV0041GetInstancesRequest) Extra(extra string) ApiSlurmdbV0041GetInstancesRequest {
	r.extra = &extra
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetInstancesRequest) Format(format string) ApiSlurmdbV0041GetInstancesRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r ApiSlurmdbV0041GetInstancesRequest) InstanceId(instanceId string) ApiSlurmdbV0041GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r ApiSlurmdbV0041GetInstancesRequest) InstanceType(instanceType string) ApiSlurmdbV0041GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

// ranged node string
func (r ApiSlurmdbV0041GetInstancesRequest) NodeList(nodeList string) ApiSlurmdbV0041GetInstancesRequest {
	r.nodeList = &nodeList
	return r
}

// time end UNIX timestamp
func (r ApiSlurmdbV0041GetInstancesRequest) TimeEnd(timeEnd string) ApiSlurmdbV0041GetInstancesRequest {
	r.timeEnd = &timeEnd
	return r
}

// time start UNIX timestamp
func (r ApiSlurmdbV0041GetInstancesRequest) TimeStart(timeStart string) ApiSlurmdbV0041GetInstancesRequest {
	r.timeStart = &timeStart
	return r
}

func (r ApiSlurmdbV0041GetInstancesRequest) Execute() (*V0041OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetInstancesExecute(r)
}

/*
SlurmdbV0041GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetInstances(ctx context.Context) ApiSlurmdbV0041GetInstancesRequest {
	return ApiSlurmdbV0041GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0041GetInstancesExecute(r ApiSlurmdbV0041GetInstancesRequest) (*V0041OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetJobRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	jobId string
}

func (r ApiSlurmdbV0041GetJobRequest) Execute() (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetJobExecute(r)
}

/*
SlurmdbV0041GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job id
 @return ApiSlurmdbV0041GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetJob(ctx context.Context, jobId string) ApiSlurmdbV0041GetJobRequest {
	return ApiSlurmdbV0041GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetJobExecute(r ApiSlurmdbV0041GetJobRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetJobsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	association *string
	cluster *string
	constraints *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	endTime *string
	startTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r ApiSlurmdbV0041GetJobsRequest) Account(account string) ApiSlurmdbV0041GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r ApiSlurmdbV0041GetJobsRequest) Association(association string) ApiSlurmdbV0041GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0041GetJobsRequest) Cluster(cluster string) ApiSlurmdbV0041GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r ApiSlurmdbV0041GetJobsRequest) Constraints(constraints string) ApiSlurmdbV0041GetJobsRequest {
	r.constraints = &constraints
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) SchedulerUnset(schedulerUnset string) ApiSlurmdbV0041GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) ApiSlurmdbV0041GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) ScheduledByMain(scheduledByMain string) ApiSlurmdbV0041GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) ApiSlurmdbV0041GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) JobStarted(jobStarted string) ApiSlurmdbV0041GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// job exit code (numeric)
func (r ApiSlurmdbV0041GetJobsRequest) ExitCode(exitCode string) ApiSlurmdbV0041GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) ShowDuplicates(showDuplicates string) ApiSlurmdbV0041GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) SkipSteps(skipSteps string) ApiSlurmdbV0041GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) ApiSlurmdbV0041GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) WholeHetjob(wholeHetjob string) ApiSlurmdbV0041GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) ApiSlurmdbV0041GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) DisableWaitForResult(disableWaitForResult string) ApiSlurmdbV0041GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) ApiSlurmdbV0041GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) ShowBatchScript(showBatchScript string) ApiSlurmdbV0041GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) ApiSlurmdbV0041GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetJobsRequest) Format(format string) ApiSlurmdbV0041GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r ApiSlurmdbV0041GetJobsRequest) Groups(groups string) ApiSlurmdbV0041GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r ApiSlurmdbV0041GetJobsRequest) JobName(jobName string) ApiSlurmdbV0041GetJobsRequest {
	r.jobName = &jobName
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0041GetJobsRequest) Partition(partition string) ApiSlurmdbV0041GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0041GetJobsRequest) Qos(qos string) ApiSlurmdbV0041GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r ApiSlurmdbV0041GetJobsRequest) Reason(reason string) ApiSlurmdbV0041GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r ApiSlurmdbV0041GetJobsRequest) Reservation(reservation string) ApiSlurmdbV0041GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r ApiSlurmdbV0041GetJobsRequest) ReservationId(reservationId string) ApiSlurmdbV0041GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r ApiSlurmdbV0041GetJobsRequest) State(state string) ApiSlurmdbV0041GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r ApiSlurmdbV0041GetJobsRequest) Step(step string) ApiSlurmdbV0041GetJobsRequest {
	r.step = &step
	return r
}

// usage end timestamp
func (r ApiSlurmdbV0041GetJobsRequest) EndTime(endTime string) ApiSlurmdbV0041GetJobsRequest {
	r.endTime = &endTime
	return r
}

// usage start timestamp
func (r ApiSlurmdbV0041GetJobsRequest) StartTime(startTime string) ApiSlurmdbV0041GetJobsRequest {
	r.startTime = &startTime
	return r
}

// ranged node string where jobs ran
func (r ApiSlurmdbV0041GetJobsRequest) Node(node string) ApiSlurmdbV0041GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r ApiSlurmdbV0041GetJobsRequest) Users(users string) ApiSlurmdbV0041GetJobsRequest {
	r.users = &users
	return r
}

// CSV wckey list
func (r ApiSlurmdbV0041GetJobsRequest) Wckey(wckey string) ApiSlurmdbV0041GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r ApiSlurmdbV0041GetJobsRequest) Execute() (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetJobsExecute(r)
}

/*
SlurmdbV0041GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetJobs(ctx context.Context) ApiSlurmdbV0041GetJobsRequest {
	return ApiSlurmdbV0041GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetJobsExecute(r ApiSlurmdbV0041GetJobsRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
}

// CSV description list
func (r ApiSlurmdbV0041GetQosRequest) Description(description string) ApiSlurmdbV0041GetQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0041GetQosRequest) Id(id string) ApiSlurmdbV0041GetQosRequest {
	r.id = &id
	return r
}

// CSV format list
func (r ApiSlurmdbV0041GetQosRequest) Format(format string) ApiSlurmdbV0041GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0041GetQosRequest) Name(name string) ApiSlurmdbV0041GetQosRequest {
	r.name = &name
	return r
}

func (r ApiSlurmdbV0041GetQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0041GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0041GetQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetQosRequest) Execute() (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetQosExecute(r)
}

/*
SlurmdbV0041GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetQos(ctx context.Context) ApiSlurmdbV0041GetQosRequest {
	return ApiSlurmdbV0041GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0041GetQosExecute(r ApiSlurmdbV0041GetQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r ApiSlurmdbV0041GetSingleQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetSingleQosRequest) Execute() (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetSingleQosExecute(r)
}

/*
SlurmdbV0041GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0041GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetSingleQos(ctx context.Context, qos string) ApiSlurmdbV0041GetSingleQosRequest {
	return ApiSlurmdbV0041GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0041GetSingleQosExecute(r ApiSlurmdbV0041GetSingleQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0041GetTresRequest) Execute() (*V0041OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetTresExecute(r)
}

/*
SlurmdbV0041GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetTres(ctx context.Context) ApiSlurmdbV0041GetTresRequest {
	return ApiSlurmdbV0041GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0041GetTresExecute(r ApiSlurmdbV0041GetTresRequest) (*V0041OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiTresResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r ApiSlurmdbV0041GetUserRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include assocations
func (r ApiSlurmdbV0041GetUserRequest) WithAssocs(withAssocs string) ApiSlurmdbV0041GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r ApiSlurmdbV0041GetUserRequest) WithCoords(withCoords string) ApiSlurmdbV0041GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include wckeys
func (r ApiSlurmdbV0041GetUserRequest) WithWckeys(withWckeys string) ApiSlurmdbV0041GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r ApiSlurmdbV0041GetUserRequest) Execute() (*V0041OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetUserExecute(r)
}

/*
SlurmdbV0041GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0041GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetUser(ctx context.Context, name string) ApiSlurmdbV0041GetUserRequest {
	return ApiSlurmdbV0041GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetUserExecute(r ApiSlurmdbV0041GetUserRequest) (*V0041OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r ApiSlurmdbV0041GetUsersRequest) AdminLevel(adminLevel string) ApiSlurmdbV0041GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r ApiSlurmdbV0041GetUsersRequest) DefaultAccount(defaultAccount string) ApiSlurmdbV0041GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default wckey list
func (r ApiSlurmdbV0041GetUsersRequest) DefaultWckey(defaultWckey string) ApiSlurmdbV0041GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r ApiSlurmdbV0041GetUsersRequest) WithAssocs(withAssocs string) ApiSlurmdbV0041GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r ApiSlurmdbV0041GetUsersRequest) WithCoords(withCoords string) ApiSlurmdbV0041GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r ApiSlurmdbV0041GetUsersRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With wckeys
func (r ApiSlurmdbV0041GetUsersRequest) WithWckeys(withWckeys string) ApiSlurmdbV0041GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r ApiSlurmdbV0041GetUsersRequest) WithoutDefaults(withoutDefaults string) ApiSlurmdbV0041GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r ApiSlurmdbV0041GetUsersRequest) Execute() (*V0041OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetUsersExecute(r)
}

/*
SlurmdbV0041GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetUsers(ctx context.Context) ApiSlurmdbV0041GetUsersRequest {
	return ApiSlurmdbV0041GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetUsersExecute(r ApiSlurmdbV0041GetUsersRequest) (*V0041OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0041GetWckeyRequest) Execute() (*V0041OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetWckeyExecute(r)
}

/*
SlurmdbV0041GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0041GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetWckey(ctx context.Context, id string) ApiSlurmdbV0041GetWckeyRequest {
	return ApiSlurmdbV0041GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeyExecute(r ApiSlurmdbV0041GetWckeyRequest) (*V0041OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041GetWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r ApiSlurmdbV0041GetWckeysRequest) Cluster(cluster string) ApiSlurmdbV0041GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// CSV format name list
func (r ApiSlurmdbV0041GetWckeysRequest) Format(format string) ApiSlurmdbV0041GetWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041GetWckeysRequest) Id(id string) ApiSlurmdbV0041GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0041GetWckeysRequest) Name(name string) ApiSlurmdbV0041GetWckeysRequest {
	r.name = &name
	return r
}

// only query defaults
func (r ApiSlurmdbV0041GetWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0041GetWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0041GetWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0041GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041GetWckeysRequest) User(user string) ApiSlurmdbV0041GetWckeysRequest {
	r.user = &user
	return r
}

// include usage with query
func (r ApiSlurmdbV0041GetWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0041GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// include deleted wckeys with query
func (r ApiSlurmdbV0041GetWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0041GetWckeysRequest) Execute() (*V0041OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetWckeysExecute(r)
}

/*
SlurmdbV0041GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeys(ctx context.Context) ApiSlurmdbV0041GetWckeysRequest {
	return ApiSlurmdbV0041GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeysExecute(r ApiSlurmdbV0041GetWckeysRequest) (*V0041OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiAccountsResp *V0041OpenapiAccountsResp
}

// Description of accounts to update/create
func (r ApiSlurmdbV0041PostAccountsRequest) V0041OpenapiAccountsResp(v0041OpenapiAccountsResp V0041OpenapiAccountsResp) ApiSlurmdbV0041PostAccountsRequest {
	r.v0041OpenapiAccountsResp = &v0041OpenapiAccountsResp
	return r
}

func (r ApiSlurmdbV0041PostAccountsRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAccountsExecute(r)
}

/*
SlurmdbV0041PostAccounts Add/update list of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAccounts(ctx context.Context) ApiSlurmdbV0041PostAccountsRequest {
	return ApiSlurmdbV0041PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsExecute(r ApiSlurmdbV0041PostAccountsRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiAccountsAddCondResp *V0041OpenapiAccountsAddCondResp
}

// Add list of accounts with conditional association
func (r ApiSlurmdbV0041PostAccountsAssociationRequest) V0041OpenapiAccountsAddCondResp(v0041OpenapiAccountsAddCondResp V0041OpenapiAccountsAddCondResp) ApiSlurmdbV0041PostAccountsAssociationRequest {
	r.v0041OpenapiAccountsAddCondResp = &v0041OpenapiAccountsAddCondResp
	return r
}

func (r ApiSlurmdbV0041PostAccountsAssociationRequest) Execute() (*V0041OpenapiAccountsAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0041PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsAssociation(ctx context.Context) ApiSlurmdbV0041PostAccountsAssociationRequest {
	return ApiSlurmdbV0041PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsAssociationExecute(r ApiSlurmdbV0041PostAccountsAssociationRequest) (*V0041OpenapiAccountsAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAccountsAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiAssocsResp *V0041OpenapiAssocsResp
}

// Job description
func (r ApiSlurmdbV0041PostAssociationsRequest) V0041OpenapiAssocsResp(v0041OpenapiAssocsResp V0041OpenapiAssocsResp) ApiSlurmdbV0041PostAssociationsRequest {
	r.v0041OpenapiAssocsResp = &v0041OpenapiAssocsResp
	return r
}

func (r ApiSlurmdbV0041PostAssociationsRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAssociationsExecute(r)
}

/*
SlurmdbV0041PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAssociations(ctx context.Context) ApiSlurmdbV0041PostAssociationsRequest {
	return ApiSlurmdbV0041PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostAssociationsExecute(r ApiSlurmdbV0041PostAssociationsRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
	v0041OpenapiClustersResp *V0041OpenapiClustersResp
}

// Filter reservations since update timestamp
func (r ApiSlurmdbV0041PostClustersRequest) UpdateTime(updateTime string) ApiSlurmdbV0041PostClustersRequest {
	r.updateTime = &updateTime
	return r
}

// Cluster add or update descriptions
func (r ApiSlurmdbV0041PostClustersRequest) V0041OpenapiClustersResp(v0041OpenapiClustersResp V0041OpenapiClustersResp) ApiSlurmdbV0041PostClustersRequest {
	r.v0041OpenapiClustersResp = &v0041OpenapiClustersResp
	return r
}

func (r ApiSlurmdbV0041PostClustersRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostClustersExecute(r)
}

/*
SlurmdbV0041PostClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostClusters(ctx context.Context) ApiSlurmdbV0041PostClustersRequest {
	return ApiSlurmdbV0041PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostClustersExecute(r ApiSlurmdbV0041PostClustersRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiSlurmdbdConfigResp *V0041OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r ApiSlurmdbV0041PostConfigRequest) V0041OpenapiSlurmdbdConfigResp(v0041OpenapiSlurmdbdConfigResp V0041OpenapiSlurmdbdConfigResp) ApiSlurmdbV0041PostConfigRequest {
	r.v0041OpenapiSlurmdbdConfigResp = &v0041OpenapiSlurmdbdConfigResp
	return r
}

func (r ApiSlurmdbV0041PostConfigRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostConfigExecute(r)
}

/*
SlurmdbV0041PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostConfig(ctx context.Context) ApiSlurmdbV0041PostConfigRequest {
	return ApiSlurmdbV0041PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostConfigExecute(r ApiSlurmdbV0041PostConfigRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
	v0041OpenapiSlurmdbdQosResp *V0041OpenapiSlurmdbdQosResp
}

// CSV description list
func (r ApiSlurmdbV0041PostQosRequest) Description(description string) ApiSlurmdbV0041PostQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0041PostQosRequest) Id(id string) ApiSlurmdbV0041PostQosRequest {
	r.id = &id
	return r
}

// CSV format list
func (r ApiSlurmdbV0041PostQosRequest) Format(format string) ApiSlurmdbV0041PostQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0041PostQosRequest) Name(name string) ApiSlurmdbV0041PostQosRequest {
	r.name = &name
	return r
}

func (r ApiSlurmdbV0041PostQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0041PostQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0041PostQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041PostQosRequest {
	r.withDeleted = &withDeleted
	return r
}

// Description of QOS to add or update
func (r ApiSlurmdbV0041PostQosRequest) V0041OpenapiSlurmdbdQosResp(v0041OpenapiSlurmdbdQosResp V0041OpenapiSlurmdbdQosResp) ApiSlurmdbV0041PostQosRequest {
	r.v0041OpenapiSlurmdbdQosResp = &v0041OpenapiSlurmdbdQosResp
	return r
}

func (r ApiSlurmdbV0041PostQosRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostQosExecute(r)
}

/*
SlurmdbV0041PostQos Add or update QOSs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostQos(ctx context.Context) ApiSlurmdbV0041PostQosRequest {
	return ApiSlurmdbV0041PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostQosExecute(r ApiSlurmdbV0041PostQosRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiTresResp *V0041OpenapiTresResp
}

// TRES descriptions. Only works in developer mode.
func (r ApiSlurmdbV0041PostTresRequest) V0041OpenapiTresResp(v0041OpenapiTresResp V0041OpenapiTresResp) ApiSlurmdbV0041PostTresRequest {
	r.v0041OpenapiTresResp = &v0041OpenapiTresResp
	return r
}

func (r ApiSlurmdbV0041PostTresRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostTresExecute(r)
}

/*
SlurmdbV0041PostTres Add TRES

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostTres(ctx context.Context) ApiSlurmdbV0041PostTresRequest {
	return ApiSlurmdbV0041PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostTresExecute(r ApiSlurmdbV0041PostTresRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0041OpenapiUsersResp *V0041OpenapiUsersResp
}

// add or update user
func (r ApiSlurmdbV0041PostUsersRequest) V0041OpenapiUsersResp(v0041OpenapiUsersResp V0041OpenapiUsersResp) ApiSlurmdbV0041PostUsersRequest {
	r.v0041OpenapiUsersResp = &v0041OpenapiUsersResp
	return r
}

func (r ApiSlurmdbV0041PostUsersRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostUsersExecute(r)
}

/*
SlurmdbV0041PostUsers Update users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostUsers(ctx context.Context) ApiSlurmdbV0041PostUsersRequest {
	return ApiSlurmdbV0041PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersExecute(r ApiSlurmdbV0041PostUsersRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	updateTime *string
	flags *string
	v0041OpenapiUsersAddCondResp *V0041OpenapiUsersAddCondResp
}

// Filter partitions since update timestamp
func (r ApiSlurmdbV0041PostUsersAssociationRequest) UpdateTime(updateTime string) ApiSlurmdbV0041PostUsersAssociationRequest {
	r.updateTime = &updateTime
	return r
}

// Query flags
func (r ApiSlurmdbV0041PostUsersAssociationRequest) Flags(flags string) ApiSlurmdbV0041PostUsersAssociationRequest {
	r.flags = &flags
	return r
}

// Create users with conditional association
func (r ApiSlurmdbV0041PostUsersAssociationRequest) V0041OpenapiUsersAddCondResp(v0041OpenapiUsersAddCondResp V0041OpenapiUsersAddCondResp) ApiSlurmdbV0041PostUsersAssociationRequest {
	r.v0041OpenapiUsersAddCondResp = &v0041OpenapiUsersAddCondResp
	return r
}

func (r ApiSlurmdbV0041PostUsersAssociationRequest) Execute() (*V0041OpenapiUsersAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostUsersAssociationExecute(r)
}

/*
SlurmdbV0041PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersAssociation(ctx context.Context) ApiSlurmdbV0041PostUsersAssociationRequest {
	return ApiSlurmdbV0041PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersAssociationExecute(r ApiSlurmdbV0041PostUsersAssociationRequest) (*V0041OpenapiUsersAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiUsersAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0041PostWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	v0041OpenapiWckeyResp *V0041OpenapiWckeyResp
}

// CSV cluster name list
func (r ApiSlurmdbV0041PostWckeysRequest) Cluster(cluster string) ApiSlurmdbV0041PostWckeysRequest {
	r.cluster = &cluster
	return r
}

// CSV format name list
func (r ApiSlurmdbV0041PostWckeysRequest) Format(format string) ApiSlurmdbV0041PostWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0041PostWckeysRequest) Id(id string) ApiSlurmdbV0041PostWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0041PostWckeysRequest) Name(name string) ApiSlurmdbV0041PostWckeysRequest {
	r.name = &name
	return r
}

// only query defaults
func (r ApiSlurmdbV0041PostWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0041PostWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0041PostWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0041PostWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0041PostWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0041PostWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0041PostWckeysRequest) User(user string) ApiSlurmdbV0041PostWckeysRequest {
	r.user = &user
	return r
}

// include usage with query
func (r ApiSlurmdbV0041PostWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0041PostWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// include deleted wckeys with query
func (r ApiSlurmdbV0041PostWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0041PostWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

// wckeys description
func (r ApiSlurmdbV0041PostWckeysRequest) V0041OpenapiWckeyResp(v0041OpenapiWckeyResp V0041OpenapiWckeyResp) ApiSlurmdbV0041PostWckeysRequest {
	r.v0041OpenapiWckeyResp = &v0041OpenapiWckeyResp
	return r
}

func (r ApiSlurmdbV0041PostWckeysRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostWckeysExecute(r)
}

/*
SlurmdbV0041PostWckeys Add or update wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0041PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostWckeys(ctx context.Context) ApiSlurmdbV0041PostWckeysRequest {
	return ApiSlurmdbV0041PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostWckeysExecute(r ApiSlurmdbV0041PostWckeysRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
